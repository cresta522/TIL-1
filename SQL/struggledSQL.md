## 読み解くのに苦戦したSQLメモ

書籍を進めていく中で例としてでてきたSQL文が、自分の今のレベルだと読み解くのに時間を要したものも少なくない。

次に読む時にスッとわかるようにも、苦戦しながら読んだSQLは記録に残しておいて、試行の過程が振り返られるようにしておく。

### NOT EXISTS句について

達人DBの「入れ子集合モデルを使った検索」の単元でNOT EXISTS句が出てきた。

一つのテーブルに二つの別名をつけて自己結合していたけど、ちょっと処理の内容の理解に苦しんだのでメモに残しておく。

社員 | 左端 | 右端
--- | --- | ---
アダム | 1 | 14
イブ | 2 | 3
セト | 4 | 13
カイン | 5 | 8
ヨブ | 6 | 7
アベル | 9 | 10
ノア | 11 | 12

こんな感じのテーブルがあってリーフ、つまり自分の中に他の円を一つも含まない円を求めるためのSQL文は

``` SQL
SELECT *
  FROM 組織図 上司
 WHERE NOT EXISTS
       (SELECT *
          FROM 組織図 部下
         WHERE 部下.左端 > 上司.左端
           AND 部下.左端 < 上司.右端);
```

NOT EXISTS句ではサブクエリの検索結果が0件の場合のみ`TRUE`を返す。

WHERE句の内容が`TRUE`になるということはその時のサブクエリの内容はメインクエリでの抽出対象となる。

先ほどのSQL文を分解してみると、まずメインクエリで取り出したレコードが一番初めの「アダム」であった場合、WHEREの内容は下記のようになる

``` SQL
WHERE 部下.左端 > 1
  AND 部下.左端 < 14
```

となる。サブクエリの結果はアダム以外全てが当てはまるため`FALSE`である。つまり、メインクエリのWHERE句での抽出対象ではない。

続いて、メインクエリで取り出すレコードが「イブ」であるとき。

``` SQL
WHERE 部下.左端 > 2
  AND 部下.左端 < 3
```

この場合、検索結果は0件。つまり、`TRUE`が返され、メインクエリでの抽出対象（リーフ)となる。

これを繰り返し行い、メインクエリで全てのレコードを抽出して確かめる。

そうすると、イブ、ヨブ、アベル、ノアが残る。これらがリーフということになる。

### BETWEEN演算子を結合条件で使っている例

上記した組織図テーブルでもうひとつSQLの例が載っていた。今度は木の深さを求めるSQL文。

> あるノードの「深さ」（階層の位置）を求める場合は、「自分を包含する円が何個あるか」という風に「包含関係」を翻訳してしやれば良い

``` SQL
-- ノードの深さを計算する
SELECT 部下.社員, COUNT(上司.社員) AS 深さ
  FROM 組織図 上司 INNER JOIN 組織図 部下
    ON 部下.左端 BETWEEN 上司.左端 AND 上司.右端
 GROUP BY 部下.社員;
```

そもそもBETWEEN演算子の使い方

``` SQL
[カラム名 BETWEEN 下限値 AND 上限値]
```
という書き方で、カラム名の下限値以上、上限値以下の場合に真を返す。

この場合、アダムが部下の場合、BETWEEN演算子の条件で真となるのは上司がアダムの場合の1行。

同じように、イブが部下の場合、上司がアダムとイブの場合のみ真となるため、抽出されるのは2行。

この抽出した行をCOUNTで数えて「部下.社員」でグループ分けをして深さを表示する。という流れ。

JOINのON句でBETWEENが使用できるのは知らなかった。結合したい情報が一列であれば、このように使用できるということでしょうかね。




--- 

参考: 「達人に学ぶDB設計徹底指南書」　ミック著











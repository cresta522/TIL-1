## Minitestについて

### Minitestを使ったテストコードの基本形

```ruby
require 'minitest/autorun'

class SampleTest < Minitest::Test
  def test_sample
    assert_equal 'RUBY', 'ruby'.upcase
  end
end
```

クラスの名前はは○○TestというようにTestで終わる。または、Testで始まる名前をつけることが多いみたい。

テストファイルの名前はsample_test.rbのようにクラスに合わせた名前にして、スネークケースで記述。

クラスの名前はSampleTestのようにキャメルケースで。


### 使用するMinitestの検証メソッド

```ruby
# aがbと等しければパスする
assert_equal b, a  #(順番注意！）

# aが真であればパスする
assert a

# aが偽であればパスする
refute a
```
他にも色々と検証メソッドはあるみたいだけど、まずはこれだけ覚えとく。

プログラム本体とテストコードはファイルを分けるのが一般的

テストコードのファイルの中で

```ruby
require 'minitest/autorun'
require './プログラムのファイルが入っているディレクトリ/プログラムファイル'
```

というようにして、テストコードのファイルから、テストしたいプログラムのファイルを読み込む。

### テスト駆動開発の開発サイクル
---
1. **先にテストを書いて失敗させる**
2. **テストがパスするような最小限のコードを書く。**
3. **リファクタリングする**

１では最初にテストコードから書き始める→テストをしてみる→失敗するのを確認→ロジックらしいロジックのない固定の値を実装する（仮実装、Fake it）  
これでテスト対象のメソッドとテストコードがちゃんとリンクしているのかを確認する。  
これをせずに、もし↑のどこかで間違えていたら、きちんとしたコードを書いても永遠にテストがパスできない状況になってしまう。

↑で書いた、ロジックのない固定の値は一つだけでなく、2つ目も書いた。（三角測量というみたい）  
テストの対象が1つしかないと、対象のメソッドが仮実装のままなのか、ロジックを実装しているのかの判別がつかないから。
